> 本文是从官网给的链接翻译过来的，原文在[这里](https://github.com/acdlite/react-fiber-architecture)。此时得react版本为`v17.0.2`。

## 1. 简介

React Fiber是对React核心算法的重新实现。这是React团队两年多的研究成果。

React Fiber的目标是增加它在动画、布局和手势等领域的适用性。它主要特点是**增量渲染**：能够将渲染工作分割成块，并将其分散到多个帧中。

其他关键特性还包括：

- 当有新的更新时，**暂停、中止或重用**工作的能力;
- 为不同类型的更新**分配优先级**的能力；
- 以及新的并发原语（new concurrency primitives）

## 2. 关于本文

Fiber引入了几个新概念，仅通过代码很难理解这些概念。这篇文档是我在React项目中跟进Fiber实现时所做的笔记的集合。随着它的发展，我意识到它对其他人也可能是一种有用的资源。

我将尝试使用最简单的语言，并通过明确定义关键术语来避免术语。如果可能的话，我还会大量链接到外部资源。

请注意，我不是React团队的成员，也没有来自任何权威机构的意见。这不是官方文件。我已经要求React团队的成员对它进行评估。

这也是一项正在进行中的工作。**Fiber是一个正在进行的项目，在完成之前可能会进行重大的重构**。同时，我还试图在这里记录它的设计。欢迎大家提出改进意见。

我的目标是，在阅读完本文之后，您将能够很好地理解Fiber，并跟随它的实现，最终甚至能够为React做出贡献。

## 3. 预备知识

我强烈建议你在继续之前熟悉以下资源，这里就点进[文章](https://github.com/acdlite/react-fiber-architecture#prerequisites)看吧.

## 4. 复习

请先看预备知识~

在真正开始前，我们先来复习几个概念。

### 4.1. 什么是协调(reconciliation)

- **协调(reconciliation)**：它是一个算法，react用它将两棵树区分开来，以确定需要修改的部分；
- **更新(update)**：用于呈现React应用程序的数据的变化。通常是`setState`的结果，最终结果是重新渲染。

React API的核心理念是**更新会导致整个应用重新渲染**。这使得开发者可以进行说明性的推理，而不用担心如何有效地将应用从任何特定状态转换到另一个状态(A到B, B到C, C到A，等等)。

实际上，在每次更改时重新渲染整个应用程序只适用于最琐碎的应用程序，在现实世界的应用程序中，它的性能成本非常高。React进行了优化，使得在保持良好性能的同时创建了整个应用程序重新渲染的外观。这些优化的大部分都是一个称为**协调**的过程的一部分。

**协调**通常被理解为“虚拟DOM”背后的算法。一个高水平的描述是这样的：当你呈现一个React应用时，会生成一棵描述该应用的节点树，并保存在内存中。然后，该树被刷新到渲染环境(rendering environment)—例如，对于浏览器应用程序，它被转换为一组DOM操作。当应用程序被更新时(通常是通过setState)，会生成一个新的树。新树与之前的树不同，用于计算需要哪些操作来更新呈现的应用程序。

虽然`Fiber`是对`协调器(reconciler)`的彻底重写，但React文档中描述的高级算法在很大程度上是相同的。重点是:

- 假设不同的组件类型会生成本质上不同的树。React不会尝试去区分它们，而是完全替换旧的树。
- 列表的差异是使用`keys`来执行的。`key`应该是“稳定的、可预测的和唯一的”。

### 4.2. 协调(reconciliation) VS 渲染(rendering)

DOM只是React可以渲染的渲染环境之一，其他主要的渲染环境也有通过React native实现原生iOS和Android视图。(这就是为什么“虚拟DOM”有点用词不当。)

它能够支持这么多目标渲染环境的原因是：因为React的设计使得协调和渲染是分开的阶段。**协调器负责计算树的哪些部分发生了变化**; 然后**渲染器使用这些信息来更新渲染的应用程序**。

这种分离意味着React DOM和React Native可以使用各自的渲染器，同时共享同一个由React core提供的协调器。

**Fiber重新实现了协调器**。它主要与渲染无关，尽管渲染器需要改变以支持(并利用)新的架构。

### 4.3. 调度(Scheduling)

- **调度(scheduling)**：决定工作何时进行的进程。
- **工作(work)**：任何必须执行的计算。工作通常是更新的结果(例如`setState`)。

React的设计原则文件在这方面非常出色，我在此引用它:
> 在其当前的实现中，React递归地遍历树，并在一个周期内调用整个更新树的渲染函数。然而，在未来，它可能会开始延迟一些更新，以避免丢失帧。
>
> 这是React设计中的一个常见主题。一些流行的库实现了“push”方法，即在新数据可用时执行计算。然而，React坚持“pull”方法，计算可以延迟到必要的时候。
>
> React不是一个通用的数据处理库。它是一个用于构建用户界面的库。我们认为它在一个应用程序中的独特位置，可以知道哪些计算是相关的，哪些是无关的。
>
> 如果某些内容不在屏幕上，我们可以延迟与之相关的任何逻辑。如果数据到达的速度比帧速率快，我们可以合并和批量更新。我们可以将来自用户交互的工作(如由按钮点击引起的动画)优先于不太重要的背景工作(如渲染刚从网络加载的新内容)，以避免掉帧。

重点是：

- 在UI中，没有必要立即应用每次更新。事实上，这样做是很浪费的，会导致帧丢失并降低用户体验。
- 不同类型的更新有不同的优先级——动画更新需要比数据存储更新更快地完成。
- 基于push的方法需要应用程序(你，程序员)来决定如何安排工作。基于pull的方法可以让框架(React)更聪明，并为你做出这些决定。

现在我们已经准备好深入研究Fiber的实现了。下一节比我们到目前为止讨论的内容更具有技术性。在继续学习之前，请确保你已经熟悉了前面的内容。

## 5. 什么是fiber

我们已经确定了Fiber的主要目标是**使React能够充分利用调度**。具体来说，我们需要能够：

- **暂停**工作，并且稍后能**继续**；
- 为不同类型的工作**分配优先级**；
- **重用**以前已完成的工作；
- **终止**无用的工作。

因此，我们首先需要一个对工作进行拆分的方案。从某种意义上来说，这就是fiber。**一个fiber代表一个工作单位**。

为了进一步了解，让我们回到React组件作为数据函数的概念，通常表示为`v = f(d)`。

渲染React应用类似于调用一个函数，而这个函数的主体包含了对其他函数的调用… 这个类比在思考fibers时很有用。

计算机通常跟踪程序执行的方式是使用调用堆栈。当一个函数执行时，一个新的堆栈帧被添加到堆栈中。堆栈框架表示该函数所执行的工作。

在处理UI时，如果执行太多的工作，可能会导致动画丢失帧，看起来不稳定。而且，如果来了一个更近的更新，那么上一次工作中有些可能时不必要的，会被新的取代。这就是UI组件和函数之间比较的地方，因为组件通常比函数有更具体的关注点。

更（四声）新的浏览器(和React Native)实现了帮助解决这个问题的api: `requestIdleCallback`计划在空闲期间调用一个低优先级的函数，`requestAnimationFrame`计划在下一个动画帧上调用一个高优先级的函数。问题在于，为了使用这些api，您需要一种将渲染工作分解为增量单元的方法。如果您只依赖于调用堆栈，那么它将继续工作，直到堆栈为空。

如果我们可以定制调用堆栈的行为来优化ui的呈现，这不是很好吗?如果我们可以随意中断调用堆栈并手动操作堆栈帧，那不是很好吗?

这就是React Fiber的目的。Fiber是栈的重新实现，专门用于React组件。您**可以将一个fiber看作一个虚拟堆栈帧**。

重新实现堆栈的好处是，您可以将堆栈帧保存在内存中，并在您想要的任何时候(以及任何时候)执行它们。这对于完成我们的调度目标是至关重要的。

除了调度之外，手动处理堆栈帧还可以释放并发性和错误边界等潜在特性。我们将在以后的章节中讨论这些主题。

在下一节中，我们将更多地研究纤维的结构。

### 5.1. 一个fiber的结构

一个Fiber是一个JS对象，包含关于组件的，输入和输出的信息。  
一个fiber对应于一个堆栈帧，但它也对应于一个组件的实例。

下面是一些关于一个fiber的重要字段。(这个列表并不详尽。)

#### 5.1.1. fiber的字段 - `type`和`key`

一个fiber的`type`和`key`的作用与React元素相同。（事实上，从一个React元素中创建出一个fiber时，`type`和`key`是直接复制过来的。）

##### 5.1.1.1. `type`

- 是用来描述fiber对应的组件：
  - 对于组合组件来说，type就是函数/类组件本身；
  - 对于宿主组件(`div`, `span`等)来说，type是一个字符串。
- 从概念上讲，`type`是正被堆栈帧跟踪其执行的函数(如`v = f(d)`)。

##### 5.1.1.2. `key`

与`type`一起，在协调过程中使用`key`来确定fiber是否可以重复使用。

#### 5.1.2. fiber的字段 - `child`和`sibling`

这两个字段指向其他fibers，描述fiber的递归树结构。

##### 5.1.2.1. `child`

指子fiber。子fiber对应组件的`render`方法返回的结果值。

看下面的栗子：

```js
function Parent() {
  return <Child />
}
// Parent的子fiber对应于Child
```

##### 5.1.2.2. `sibling`

`sibling`字段对应`render`方法返回多个子元素的情况：

```js
function Parent() {
  return [<Child1 />, <Child2 />]
}
// [<Child1 />, <Child2 />]形成了一个单链表，头是第一个子fiber。
// 在这里，Parent的子fiber(child)的hiChild1，Child1的兄弟fiber(sibling)是Child2。
```

#### 5.1.3. fiber的字段 - `return`

`return`指返回的fiber。是程序处理完当前fiber后应返回的fiber。它在概念上与堆栈帧的返回地址相同。它也可以被认为是母fiber。

如果一个fiber有多个子fiber，每个子fiber的返回fiber是父fiber。所以在上一节的例子中，Child1和Child2的返回fiber是Parent。

#### 5.1.4. fiber的字段 - `pendingProps`和`memoizedProps`

从概念上讲，props是函数的参数。fiber的`pendingProps`在它执行开始时设置，`memoizedProps`在执行结束时设置。

当输入的`pendingProps`和`memoizedProps`相等时，它表示fiber以前的输出可以重用，防止不必要的工作。

#### 5.1.5. fiber的字段 - `pendingWorkPriority`

`pendingWorkPriority`是一个数字，表示fiber所代表的工作优先级。ReactPriorityLevel模块列出了不同的优先级级别及其表示的内容。

除`NoWork`(为0)外，**数值越大优先级越低**。

例如，你可以使用下面的函数来检查fiber的优先级是否至少和给定的级别一样高:

```js
// 这个函数只是为了演示;它实际上不是React Fiber代码库的一部分。
function matchesPriority(fiber, priority) {
  return fiber.pendingWorkPriority !== 0 &&
         fiber.pendingWorkPriority <= priority
}
```

调度器使用优先级字段搜索要执行的下一个工作单元。这个算法将在以后的章节中讨论。

#### 5.1.6. fiber的字段 - `alternate`

- `flush`：冲洗(flush)一个fiber就是将fiber的输出渲染到屏幕上。
- `work-in-progress`：指一个尚未完成的fiber。概念上来将，它指还没有返回的堆栈帧。

在任何时候，一个组件实例最多有两个对应于它的光纤：`当前fiber`、`flushed fiber`和`work-in-progress fiber`。

`当前fiber`会被`work-in-progress fiber`替换，`work-in-progress fiber`会被`flushed fiber`替换。

一个fiber的替换过程是使用一个名为`cloneFiber`的函数惰性创建的。`cloneFiber`会尝试重用fiber的备用方案(如果存在的话)，以此避免总是创建一个新对象，从而最小化分配。

您应该将`alternate`字段视为一个实现细节，但是它经常出现在代码库中，因此在这里讨论它是有价值的。

#### 5.1.7. fiber的字段 - `output`

`host component`：React应用程序的叶节点。它们是特定于渲染环境的(例如，在浏览器应用程序中，它们是' div '， ' span '等)。在JSX中，它们使用小写的标记名表示。

从概念上讲，fiber的输出就是函数的返回值。

每个fiber最终都有输出，但输出仅由宿主组件在叶子节点上创建。然后，输出被向上传输到树中。

`output`是最终提供给呈现器的内容，以便它能够将更改刷新到渲染环境。定义如何创建和更新输出是渲染器的责任。

## 6. 关于未来的畅想

这就是现在所有的内容，但是这个文档还远远没有完成。以后的章节将描述在更新的整个生命周期中使用的算法。

相关的视频：<https://youtu.be/aV1271hd9ew>
