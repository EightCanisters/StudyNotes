## 1. 命令行入门基础

### 1.1. 命令行提示符介绍

🌰比如：`[root@www ~]#`、`[zhangsan@www ~]$`

- `#`：使用超级用户root登录后的命令行结尾提示符；
- `$`：使用普通用户登录后的命令行结尾提示符；
- `@前的字符`：代表当前登录的用户，可使用`whoami`查询。对应上面🌰中的`root`, `zhangsan`;
- `@后的字符`：代表主机名，可使用`hostname`查询。对应上面🌰中的`www`;
- `~的位置`：表示窗口当前用户所在的路径，可用`pwd`命令查询。

### 1.2. 常用快捷键

| **快捷键** | **功能说明** |
| --- | --- |
| tab | 补全命令或者路径 |
| ctrl + r | 搜索命令行使用过的历史命令记录 |
| ctrl + g | 从执行ctrl + r命令模式中退出 |
| ctrl + a | 光标移动到行首 |
| ctrl + e | 光标移动到行尾 |
| ctrl + h | 删除光标前一个字符 |
| ctrl + d | 删除光标后的一个字符，若命令行无字符，则会退出当前shell命令行 |
| ctrl + u | 剪切（删除）光标处到行首的字符 |
| ctrl + k | 剪切（删除）光标处到行尾的字符 |
| ctrl + y | 粘贴以上两个命令剪切的内容 |
| ctrl + insert | 复制命令行内容 |
| shift + insert | 粘贴命令行内容 |
| ctrl + l | 清除屏幕所有内容 |
| ctrl + s | 锁定终端，使之无法输入内容 |
| ctrl + q | 解锁锁定的状态 |

## 2. Linux目录结构介绍

linux与Windows的目录结构对比如下图所示，从图中可以看出Linux系统的目录结构具有如下基本特点：

- Linux系统的目录起点都是从“/”根开始的
- 根下面的目录是一个有层次的树状结构

![linux目录介绍](http://rc9frlwp7.hn-bkt.clouddn.com/linux-目录.png)

| **目录** | **说明** |
| --- | --- |
| /bin | 常用的二进制命令所在的目录。比如 ls、cp、mkdir、rm等命令 |
| /boot | 存放着启动Linux时使用的一些核心文件，包括一些连接文件以及镜像文件 |
| /dev  | 存放着Linux的外部设备 * |
| /etc  | 存放所有的系统管理所需要的的配置文件和子目录 * |
| /home | 用户的主目录，在Linux中，每个用户都有一个自己的目录，一般是以用户的账号命令 * |
| /lib | 启动系统和运行命令所需要的共享库文件和内核模块存放目录 |
| /opt | 被保留用于安装额外的应用软件包目录，例如通过源码包安装的软件 |
| /root | 超级权限用户root的家目录 |
| /sbin | 大多涉及系统管理命令的存放，是超级权限用户root可执行命令的存放地 * |
| /tmp | 临时文件目录 |
| /usr | 用户软件资源目录，用户的很多应用程序和文件都放在这个目录下，类似window下的program files目录 |
| /var | variable data的缩写，这个目录的内容是经常变动的，日志一般存放在/var/log下 |

## 3. 文件目录相关命令

### 3.1. 文件及目录管理

#### `pwd`: 显示当前所在位置的信息

在实际工作中，我们在命令行操作命令时，经常会在各个目录路径间进行切换，此时可使用pwd命令快速查看当前所在的目录路径。

**👀语法格式：**  

```
pwd [option]
```

**🧐说明：**  

- pwd 命令与后面的选项之间至少要有一个空格;
- 通常情况下，执行pwd命令不需要附带任何参数

#### `cd`: 切换目录

从当前工作目录切换到指定的工作目录。

**👀语法格式：**  

```
cd [option] [dir]
```

**🧐说明：**  

- 注意cd命令以及后面的选项和目录，每个元素之间都至少要有一个空格;
- `cd`命令后面的选项和目录等参数都可以省略。默认情况下，单独执行cd命令，可切换到当前登录用户的家目录（由系统环境变量HOME进行定义）;
- cd是`bash shell`的内置命令，查看该命令对应的系统帮助需要使用`help cd`.

| **option** | **说明** |
| --- | --- |
| -P | 如果切换的目标目录是一个软连接，则会直接切换到软连接指向的真正的物理目标目录，不常用 |
| -L | 功能与-P相反，如果切换的目标目录是一个软连接，则直接切换到软连接所在的目录，不常用 |
| - | 若只使用“-”选项，则将会从当前目录切换到当前用户的上一次所在的目录路径 * |
| ~ | 若只使用“~”选项，则将会从当前目录切换到系统环境变量“HOME”对应值的目录路径，即当前用户的家目录所在的路径 *  |
| .. | 若只使用“..”选项，则将会从当前目录切换到当前目录的上一级目录所在的路径 * |

#### `tree`: 以树形结构显示目录下的内容

以树形结构列出指定目录下的所有内容，包括所有文件、子目录及子目录里的目录和文件

**👀语法格式：**  

```
tree [option] [dir]
```

**🧐说明：**  
  
- 注意tree命令以及后面的选项和目录，每个元素之间都至少要有一个空格
- 若tree命令后不接选项和目录，则默认显示当前所在路径目录的目录结构

| **option** | **说明** |
| --- | --- |
| -a | 显示所有文件，包括隐藏文件 |
| -d | 只显示目录 * |
| -f | 显示每个文件的全路径 |
| -i | 不显示数值，常与 -f 配合使用 |
| -L level | 遍历目录的最大层数，level为大于0的正整数 |

#### `mkdir`：创建目录

默认情况下，如果要创建的目录已经存在，则会提示文件存在，而不会继续创建目录

**👀语法格式：**  

```
mkdir [option] [dir]
```

**🧐说明：**  

| **option** | **说明** |
| --- | --- |
| -p | 递归创建目录 |
| -v | 显示创建目录的过程 |

##### 🌰栗子

```
mkdir test // 在当前目录下创建test文件夹

// 前提：当前目录下无renrui文件夹
mkdir renrui/test // 报错，提示当前目录下无renrui文件夹
mkdir -p renrui/test // 会创建renrui/test两个文件夹
```

#### `touch`：创建文件或更改文件时间戳

touch命令包含两个功能：一是创建新的空文件；二是改变已有文件的时间戳属性

**👀语法格式：**  

```
touch [option] [file]
```

**🧐说明：**  

- touch命令以及后面的选项和文件，每个元素之间都至少要有一个空格；
- 注意区分`touch`和`mkdir`命令的功能，`mkdir`命令是**创建空目录**，而`touch`是**创建空文件**；
- 在Linux中，一切皆文件。虽然`touch`命令不能创建目录，但是可以修改目录的时间戳。

#### `ls`：显示目录下内容及属性信息

列出目录的内容及其内容属性信息

**👀语法格式：**  

```
ls [option] [file]
```

**🧐说明：**  

- ls命令以及后面的选项和文件，每个元素之间都至少要有一个空格；
- 命令后面的选项和目录文件可以省略，表示查看当前路径的文件信息。

| **option** | **说明** |
| --- | --- |
| -l | 使用长格式列出文件及目录信息 (同`ll`) * |
| -s | 显示目录下的所有文件，包括隐藏文件 * |
| -t | 根据最后的修改时间进行排序，默认是以文件名进行排序的 * |
| -r | 以相反顺序排序 * |
| -d | 当遇到目录是，列出目录本身而非目录内的文件，并且不跟随符号链接 * |
| -h | 以人类可读的信息显示文件或目录的大小 * |
| -S | 根据文件大小进行排序 |
| -R | 递归列出所有子目录 |

#### cp：复制文件或目录

**👀语法格式：**  

```
cp [option] [source] [dest]
```

**🧐说明：**  

| **option** | **说明** |
| --- | --- |
| -p | 复制文件时保持源文件的所有者、权限信息以及时间属性 |
| -d | 如果复制的源文件是符号链接，则仅复制符号链接本身，而且保留符号链接所指向的目标文件或者目录 |
| -r | 递归复制目录，即复制目录下的所有层级的子目录及文件 * |
| -a | 等同于上面的 p d r三个选项的功能总和 * |

#### `mv`：移动或重命名文件

**👀语法格式：**  

```
mv [option] [source] [dest]
```

**🧐说明：**  

| **option** | **说明** |
| --- | --- |
| -f | 若目标文件已存在，则不会询问而是直接覆盖 |
| -i | 若目标文件已存在，则会询问是否覆盖 |
| -n | 不覆盖已经存在的文件 |

#### `rm`：删除文件或目录

删除一个或多个文件或目录

**👀语法格式：**  

```
rm [option] [file]
```

**🧐说明：**  

| **option** | **说明** |
| --- | --- |
| -f | 强制删除，忽略不存在的文件，不提示确认 * |
| -i | 在删除前需要确认 |
| -r | 递归删除目录及其内容 * |

#### du：统计磁盘空间使用情况

du命令可以用于统计磁盘空间的使用情况，这个命令有助于我们找出哪个文件过多地占用了磁盘空间

**👀语法格式：**  

```
du [option] [file]
```

**🧐说明：**  

| **option** | **说明** |
| --- | --- |
| -a | 显示所有文件大小 |
| -h | 以人类可读的方式查看大小，以K，M，G为单位 * |
| -s | 显示文件的总大小 * |

### 3.2. 文件过滤及内容编辑

#### `vi/vim`：纯文本编辑器

vi是Linux命令行界面下的重要文字编辑器。vim是vi命令的增强版，例如，高亮显示代码、自动缩进等

**👀语法格式：**  

```
vim [option] [file]
```

**🤔vim的三种模式：**  

（1）普通模式：  
用vim命令打开一个文件后，默认的状态就是普通模式。在这个模式中，不能进行编辑输入操作，但可以按“上下左右”键来移动光标，同时还可以执行一些操作命令进行如删除、复制、粘贴等工作  
（2）编辑模式：  
在普通模式下不能进行编辑输入操作，只有按下“i，I，o，O，a，A，r，R，s，S”（其中“i”最为常用）等字母进入编辑模式后才可以执行录入文字等编辑操作。确定文件是否处于编辑模式状态有一个重要的特征，那就是在窗口的左下角要有插入的标记“--INSERT--”或“--插入--”  
（3）命令模式：  
在普通模式下，输入“：”或“/”或“？”时，光标会自动定位在那一行，在这个模式中，可以执行保存、退出、搜索、替换、显示行号等相关操作

**🧐说明：**  

| **option** | **说明** |
| --- | --- |
| 普通模式：移动光标的操作 |  |
| G或（shift+g） | 将光标移动到文件的最后一行 |
| gg | 将光标移动到文件的第一行 |
| 0 | 将光标从所在位置移动到当前行的开头 |
| $ | 将光标从所在位置移动到当前行的结尾 |
| n<Enter> | n为数字，<Enter>为回车键，将光标从当前位置向下移动n行 |
| ngg | n为数字，移动到文件的第n行，如11gg可移动到第11行 |
| H | 光标移动到当前窗口最上方的那一行 |
| M | 光标移动到当前窗口中间的那一行 |
| L | 光标移动到当前窗口最下方的那一行 |
| 普通模式：搜索与替换操作 |  |
| /hello | 从光标位置开始，向下寻找名为hello的字符串 |
| ?hello | 从光标位置开始，向上寻找名为hello的字符串 |
| 普通模式：复制、粘贴、删除等操作 |  |
| yy | 复制光标所在的当前行 |
| nyy | n为数字，复制光标开始向下的共n行 |
| p/P | p将已复制的数据粘贴到光标的下一行，P则为粘贴到光标的上一行 |
| dd | 删除（剪切）光标所在的当前行 |
| ndd | n为数字，删除从光标开始向下共n行 |
| u | 恢复（回滚）前一个执行过的操作 |
| x/X | x为向后删除字符，X为向前删除字符 |
| dlG | 删除当前行至第一行 |
| dG | 删除当前行至最后一行 |
| d0 | 删除当前光标文本至行首 |
| d$ | 删除当前光标文本至行尾 |
| 进入编辑模式命令 |  |
| i | 在当前光标所在处插入文字 |
| a | 在当前光标所在处的下一个字符处插入文字 |
| I | 在当前所在行的行首的第一个非空格符处开始插入文字 |
| A | 在当前所在行的行尾的最后一个字符处开始插入文字 |
| Esc | 退出编辑模式，回到命令模式中 |
| 命令行模式 |  |
| :wq | 退出并保存 |
| :wq! | 退出并强制保存 |
| :q! | 强制退出，不保存 |
| :set nu | 显示行号 |
| :set nonu | 取消行号 |

#### `echo`：显示输出文本内容

`echo`命令能将指定文本显示在Linux命令行上，或者通过重定向符（>>）写入到指定的文件中

**👀语法格式：**  

```
echo [option] [文本]
```

**🧐说明：**  

| **option** | **说明** |
| --- | --- |
| -n | 不要自动换行 |
| -e | 若字符串中出现以下字符，则需要进行特别处理，而不会将它当成一般文字输出

- \a 发出警告声
- \b 删除前一个字符
- \c 最后不加上换行符号
- \f 换行但光标仍旧停留在原来的位置
- \n 换行且光标移至行首
- 光标移至行首，但不换行
- \t 插入tab
 |

#### `cat`：合并文件或查看文件内容

此命令常用于显示单个文件内容，或者将几个文件内容连接起来一起显示，还可以从标准输入中读取内容并显示

**👀语法格式：**  

```
cat [option] [file]
```

**🧐说明：**  

| **option** | **说明** |
| --- | --- |
| -n | 从1开始对所有输出内容按行编号 |
| -b | 与-n选项功能类似，但忽略显示空白行行号 |

#### `more`：分页显示文件内容

more命令的功能类似于cat，但cat命令是将整个文件的内容一次性地显示在屏幕上，而more则会一页一页地显示文件内容。

**👀语法格式：**  

```
more [option] [file]
```

**🧐说明：**  

| **option** | **说明** |
| --- | --- |
| -num | 指定屏幕显示大小为num行 |
| +num | 从行号num开始显示 * |

在交互模式下，使用more命令打开文本后，会进入一个基于vi的交互界面，在这里可以使用部分vi编辑器的功能，如搜索功能，还可以切换到vi编辑器。下表给出了more命令的交互式子命令

| **子命令** | **说明** |
| --- | --- |
| 空格键 | 向下滚动一屏 * |
| b | 返回上一屏 * |
| = | 输出当前行的行号 |
| /查找的文本 | 查找指定文本 * |
| v | 调用vi编辑器 |
| q | 退出more |

#### `less`：分页显示文件内容

less命令的基本功能类似于more命令，可以分页显示文件内容，但比more的功能更强大。less命令在读取文件内容时，并不是像more、vi命令一样，需要一次性将整个文件加载之后再显示，而是会根据需要来加载文件内容，这样打开文件的速度更快。而且less命令支持[page up]、[page down]等按键的功能，可通过该功能往前或往后翻看文件，这样更容易查看一个文件的内容

**👀语法格式：**  

```
less [option] [file]
```

**🧐说明：**  

| **option** | **说明** |
| --- | --- |
| -i | 搜索时忽略大小写 |
| -N | 显示每行的行号 * |
| -e | 当文件显示到结尾时自动退出文件，若不使用此选项则需要使用交互式命令q退出less |

在交互模式下，less命令也是基于more命令和vi命令的，在这里可以使用vi编辑器的部分功能，如搜索功能，还可以切换到vi编辑器。下表给出了less命令的交互式子命令

| **子命令** | **说明** |
| --- | --- |
| b/page up | 向前翻一页 * |
| 空格键/page down | 向后翻一页 * |
| y/ ↑ | 向上滚动一行 |
| 回车键/↓ | 向下滚动一行 |
| /字符串 | 向下搜索“字符串” |
| ?字符串 | 向上搜索“字符串” |
| n | 向后查找下一个匹配的文本 |
| N | 向前查找前一个匹配的文本 |
| v | 进入vi编辑界面 |
| G | 移动到最后一行 |
| g | 移动到第一行 |
| q | 退出less命令 |

#### `head`：显示文件头部内容

head命令用于显示文件头部的内容，执行head命令默认会输出文件的开头10行内容

**👀语法格式：**  

```
head [option] [file]
```

**🧐说明：**  

| **option** | **说明** |
| --- | --- |
| -n <行数> | 指定显示的行数 * |

#### `tail`：显示文件内容尾部

tail命令用于显示文件尾部的内容，tail命令默认输出文件的最后10行

**👀语法格式：**  

```
tail [option] [file]
```

**🧐说明：**  

| **option** | **说明** |
| --- | --- |
| -n <行数> | 指定显示的行数 * |
| -f | 实时输出文件变化后追加的数据 * |

#### `tailf`：跟踪日志文件

tailf命令在工作中的主要使命就是跟踪日志文件，首先将默认输出日志文件的最后10行，然后实时地显示文件的增加内容。
tailf命令几乎等同于tail-f，与tail-f不同的是，如果文件不增长，那么它不会去访问磁盘文件，也不会更改文件的访问时间

**👀语法格式：**  

```
tailf [option] [file]
```

**🧐说明：**  

| **option** | **说明** |
| --- | --- |
| -n <行数> | 指定显示的行数 * |

#### `grep`：文本过滤工具

grep命令是Linux系统中最重要的命令之一，其功能是从文本文件或管道数据流中筛选匹配的行及数据，如果配合正则表达式技术一起使用，则功能会更加强大

**👀语法格式：**  

grep [option] [pattern] [file]
pattern：grep命令里面的匹配模式，都是你要获取的内容，它们既可以是普通的文字符号也可以是正则表达式

**🧐说明：**  

| **option** | **说明** |
| --- | --- |
| -v | 显示不包含匹配文本的所有行 * |
| -n | 显示陪陪的行及行号 * |
| -i | 不区分大小写，默认是区分大小写的 * |
| -w | 以单词为单位进行过滤 * |

### 3.3. 文件及目录查找

#### `which`：显示命令的全路径

which命令用于显示命令的全路径，我们常用这个命令查找命令在哪里，which命令查找的范围是PATH环境变量的路径

**👀语法格式：**  

which [option] [filename]

**🧐说明：**  

| **option** | **说明** |
| --- | --- |
| -a | 默认在PATH路径中由前往后查找命令，如果能够查找到就停止匹配。-a将遍历所有的PATH路径，并输出所有匹配项 |

#### `whereis`：显示命令及其相关文件全路径

whereis命令用于定位在PATH环境变量里查找指定命令的可执行文件、源码文件及man帮助文件的路径

**👀语法格式：**  

whereis [option] [filename]

**🧐说明：**  

| **option** | **说明** |
| --- | --- |
| -b | 查找可执行文件 |
| -m | 查找man帮助文件 |
| -s | 查找源代码文件 |

#### `locate`：快速定位文件路径

**👀语法格式：**  

locate [option] [filename]

**🧐说明：**  

| **option** | **说明** |
| --- | --- |
| -c | 不显示匹配的内容，只显示匹配到的行数 |
| -i | 匹配时忽略大小写 |
| -r | 支持基本正则表达式匹配 |

#### `find`：查找目录下的文件

find命令用于查找目录下的文件，同时还可以调用其他命令执行相应的操作

**👀语法格式：**  

![](http://rc9frlwp7.hn-bkt.clouddn.com/libux-find.png)

**🧐说明：**  

| **参数选项** | **说明** |
| --- | --- |
| path | 命令所查找的目录路径，如用“.”来表示当前目录，用“/”来表示系统根目录 * |
| **_options模块_** |  |
| -depth | 从指定目录下最深层的子目录开始查找 |
| -maxdepth levels | 查找的最大目录级数，levels为自然数 |
| _**tests模块**_ |  |
| -mtime [-n|n|+n] | 按照文件的修改时间来查找文件 *

- -n 文件更改时间距现在n天以内
- n   文件更改时间距现在n天以前
- +n 距离现在第n天
 |
| -atime [-n|n|+n] | 按照文件的访问时间来查找文件，单位是天 |
| -amin | 按照文件的访问时间来查找文件，单位是分钟 |
| -mmin | 按照文件的修改时间来查找文件，单位是分钟 |
| -group | 按照文件所属的组来查找文件 |
| -name | 按照文件名查找文件，只支持“*”、“?”、“[]”等特殊通配符* |
| -regex | 接正则表达式 |
| -type | 查找某一类型的文件 *|
| **_actions模块_** |  |
| -delete | 将查找出的文件删除 |
| ! | 取反* |

### 3.4. 文件备份与压缩

#### `tar`：打包备份

在Linux系统里，tar是将多个文件打包在一起，并且可以实现解压打包的文件的命令。是系统管理员最常用的命令之一，tar命令不但可以实现对多个文件进行打包，还可以对多个文件打包后进行压缩
打包是指将一大堆文件或目录变成一个总的文件，压缩则是将一个大的文件通过一些压缩算法变成一个小文件

**👀语法格式：**  

```
tar [option] [file]
```

**🧐说明：**  

| **option** | **说明** |
| --- | --- |
| -z | 通过gzip压缩或者解压 * |
| -c | 创建新的 tar 包 * |
| -v | 显示详细的tar命令执行过程 * |
| -f | , * |
| -t | 不解压查看tar包的内容 * |
| -x | 解开tar包 * |
| C | 指定解压的目录路径 * |
| --exclude=PATTERN | 打包时排除不需要处理的文件或目录，可以多个并列使用 * |

在打包一个目录之前，先进入到这个目录的上一级目录，然后执行打包命令，这是大部分情况下打包文件的规范操作流程。少数情况下，当打包需要完整的目录结构时，可以使用绝对路径进行打包，但是需要注意解压tar包时压缩包内的文件是否会覆盖原始文件

#### zip：打包和压缩文件

zip压缩格式是Windows与Linux等多平台通用的压缩格式。zip命令压缩文件不仅不会删除源文件，而且还可以压缩目录

**👀语法格式：**  

```
zip [option] [file]
```

**🧐说明：**  

| **option** | **说明** |
| --- | --- |
| -r | 将指定目录下的所有文件和子目录一并压缩 * |
| -x | 压缩文件时排除某个文件 * |
| -q | 不显示压缩信息 |

#### unzip：解压zip文件

unzip命令可以解压zip命令或其他压缩软件压缩的zip格式的文件

**👀语法格式：**  

```
unzip [option] [file]
```

**🧐说明：**  

| **option** | **说明** |
| --- | --- |
| -l | 不解压显示压缩包的内容 |
| -d | 指定解压目录 |
| -v | 解压时显示详细信息 |

## 4. 通配符

### 通配符之“*”

在Linux命令行通配符中，“*”号的意思是匹配所有（0到多个）字符，这在查找某一类文件时特别方便，它在命令行中是十分常用的符号
例如：查看所有结尾为sh的文件
ls*.sh

### 通配符之“？”

在Linux命令行通配符中，“？”号代表的是任意一个字符（有且只有一个）

### 通配符之[abcd]

在Linux命令行通配符中，“[]”（中括号）这个符号里面可以加abcd等0到多个字符，表示匹配abcd中的任意一个字符（a、b、c、d中有且只有一个）

### 通配符之[a-z]

“[]”（中括号）这个符号里面的a-z，表示匹配a到z中的任意一个字符（有且只有一个），a-z要连续，也可以用连续的数字替代，例如，[1-9]表示的就是匹配1到9中的任意一个字符

### 通配符之[！abcd]

[！abcd]表示匹配除了abcd四个字符以外的任意一个字符（有且只有一个），也可以写成[^abcd]或[^a-d]，还可以用连续的数字替代，例如[^1-9]

## 5. 用户管理

Linux是一个多用户分时系统，想要使用系统资源，就必须在系统中有合法的账号，每个账号都有一个唯一的用户名，同时必须设置密码。在系统中使用用户的概念，一方面可以方便识别不同的用户，另一方面也可以为用户设置合理的文件权限，为每个用户的数据提供安全保障。另外，为了更灵活地管理用户和控制文件权限，Linux还采用了用户组的概念，这为系统管理提供了极大的便利

### 用户及用户组配置文件

在Linux系统中，与用户相关的配置文件主要包含如下两个:

- /etc/passwd：存储用户信息的文件
- /etc/shadow：存储用户密码信息的文件

在Linux系统中，与用户组直接相关的主要配置文件也有两个：

- /etc/group：用户组信息文件
- /etc/gshadow：用户组密码信息文件

### 有关用户管理的常见命令汇总

| **命令** | **说明** |
| --- | --- |
| 与用户直接相关的命令 |  |
| useradd | 添加用户 |
| usermod | 修改用户信息 |
| userdel | 删除用户及与用户有关联的配置或文件 |
| 与用户密码直接相关的命令 |  |
| passwd | 为用户设置或修改密码 |
| chpasswd | 批量更新用户密码 |
| chage | 修改用户密码属性信息 |
| 与其他用户相关的命令 |  |
| su | 切换用户角色工具 |
| sudo | 以一个其他用户身份（主要是root用户）执行命令的工具，普通用户用来提权的重要工具 |

### 有关用户组管理的常见命令汇总

| **命令** | **说明** |
| --- | --- |
| groupadd | 添加用户组 |
| groupdel | 删除用户组 |

### `su`：用户身份切换命令

一般在普通用户需要超级用户的权限时，可以通过su命令来切换用户身份

**👀语法格式：**  

```
su [option] [username]
```

**🧐说明：**  

- 若命令后面的用户名省略了，则默认切换为root用户
- 从root用户切换到普通用户时，不需要任何密码，从普通用户切换到root用户时，则需要输入root密码

| **option** | **说明** |
| --- | --- |
| -，-l，--login | 使一个Shell成为登录的Shell，如执行su - zhangsan时，表示该用户希望改变的身份为zhagnsan，并且使用zhagnsan用户对应的环境变量配置 |

若不添加任何参数执行su命令，则表示要切换到root用户，但是这样执行，会遇到一些问题。因为虽然是切换到root用户了，但并没有改变root用户登录后的环境，有些登录的环境设置还是登录前的用户的。生产场景规范的操作方法是“su -”

### `sudo`：以另一个用户身份执行命令

sudo命令可以让普通用户在执行指定的命令或程序时，拥有超级用户（也可以是其他用户）的权限，并且可以有针对性地（精细）将不同命令或程序授予指定的普通用户，同时普通用户不需要知道root密码就可以得到授权

**👀语法格式：**  

```
sudo [option]
```

**🧐说明：**  

| **option** | **说明** |
| --- | --- |
| -l | 列出当前用户可以执行的命令 |

- 通过sudo授权管理后，所有用户执行授权的特殊权限格式为“sudo命令”
- 如果需要切换到root执行相关操作，则可以通过“sudo su-”命令，注意，此命令提示的密码为当前用户的密码，而不是root的密码
- 执行“sudo-l”命令可以查看当前用户被授予的sudo权限集合

## 6. 进程管理

### `ps`：查看进程

ps命令用于列出执行ps命令的那个时刻的进程快照，就像用手机给进程照了一张照片。如果想要动态地显示进程的信息，就需要使用top命令，该命令类似于把手机切换成录像模式

**👀语法格式：**  

```
ps [option]
```

| **option** | **说明** |
| --- | --- |
| -a | 显示所有终端下执行的进程 |
| a | 显示与终端相关的所有进程，包含每个进程的完整路径 * |
| x | 显示与终端无关的所有进程 * |
| u | 显示进程的用户信息 * |
| -e | 显示所有进程 * |
| -f | 额外显示UID、PPID、C（CPU使用的资源百分比）与STIME栏 * |

默认情况下，ps命令不接任何参数时，输出的是使用者当前所在终端（窗口）的进程，如下：
![image.png](https://cdn.nlark.com/yuque/0/2020/png/703037/1602398030157-169ad187-441a-4315-96d9-593b9c641134.png#height=46&id=JAXRD&margin=%5Bobject%20Object%5D&name=image.png&originHeight=46&originWidth=601&originalType=binary&ratio=1&size=3254&status=done&style=none&width=601)

**🧐说明：**  

- PID是进程的标识号
- TTY是进程所属的终端控制台
- TIME列是进程所使用的总的CPU时间
- CMD列是正在执行的命令行

**🤔常用操作组合：**  
**1）ps -ef**
![image.png](https://cdn.nlark.com/yuque/0/2020/png/703037/1602398210895-9acced53-6ba8-45f2-b39c-c2450eca00ab.png#height=199&id=eLvy7&margin=%5Bobject%20Object%5D&name=image.png&originHeight=199&originWidth=810&originalType=binary&ratio=1&size=22700&status=done&style=none&width=810)

说明👇  

- UID：进程被该UID所拥有
- PID：进程的标识号
- PPID：进程的父进程的标识号
- C：CPU使用的资源百分比
- STIME：进程开始的时间
- TTY：该进程是在哪个终端机上面运作，若与终端机无关，则显示“?”，另外，tty1-tty6是本机上面的登入者进程，若为pts/0等，则表示为由网络连接进主机的进程
- TIME：进程所使用的总的CPU时间
- CMD：正在执行的命令行

**2）ps -ef|grep 关键字**
**3）ps aux**
![image.png](https://cdn.nlark.com/yuque/0/2020/png/703037/1602398448662-9458e6c1-2ab5-4e61-a44a-ecdcb34e2b87.png#height=170&id=qnXt1&margin=%5Bobject%20Object%5D&name=image.png&originHeight=170&originWidth=926&originalType=binary&ratio=1&size=22883&status=done&style=none&width=926)

说明👇  

- USER：该进程属于的用户
- PID：该进程的进程号
- %CPU：该进程使用掉的CPU资源百分比
- %MEM：该进程所占用的物理内存百分比
- VSZ：该进程使用掉的虚拟内存量（单位为Kbytes）
- RSS：该进程占用的固定的内存量（单位为Kbytes）
- STAT：该进程目前的状态，主要的状态包括如下几种
  - R：正在运行，或者是可以运行
  - S：正在中断睡眠中，可以由某些信号（signal）唤醒
  - D：不可中断睡眠
  - T：正在侦测或者是停止了
  - Z：已经终止，但是其父进程无法正常终止它，从而变成zombie（僵尸）进程的状态
  - +：前台进程
  - l：多线程进程
  - N：低优先级进程
  - <：高优先级进程
  - s：进程领导者
  - L：已将页面锁定到内存中
- START：该进程被触发启动的时间
- COMMAND：该进程的实际命令

### `kill`：终止进程

kill命令能够终止你希望停止的进程

**👀语法格式：**  

```
kill [option] [pid] // pid: 进程号
```

**🧐说明：**  

| **option** | **说明** |
| --- | --- |
| -l | 列出全部的信号名称 |
| -s | 指定要发送的信号 |

### `killall`：通过进程名终止进程

使用kill命令终止进程还需要先获取进程的pid进程号，这个过程有点繁琐，而使用killall命令就可以直接用“killall 进程名”这种形式终止进程

**👀语法格式：**  

```
killall [option] [name]
```

**🧐说明：**  

| **option** | **说明** |
| --- | --- |
| -u | 终止指定用户的进程 |

### `pkill`：通过进程名终止进程

pkill命令可通过进程名终止指定的进程。使用killall终止进程需要连续执行几次，而pkill可以杀死指定进程及其所有子进程

**👀语法格式：**  

```
pkill [option] [name]
```

**🧐说明：**  

| **option** | **说明** |
| --- | --- |
| -u 用户 | 杀死指定用户的进程 |

### `top`：实时显示系统中各个进程的资源占用状况

top命令用于实时地对系统处理器状态进行监控，它能够实时地显示系统中各个进程的资源占用状况。该命令可以按照CPU的使用、内存的使用和执行时间对系统任务进程进行排序显示，同时top命令还可以通过交互式命令进行设定显示

**👀语法格式：**  

```
top [option]
```

**🧐说明：**  

| **option** | **说明** |
| --- | --- |
| -n | 将进程按照使用内存排序 |
| -c | 显示进程的整个命令路径，而不是只显示命令的名称 |
| -H | 显示每个线程的情况，否则就是进程的总的状态 |
| -i | 不显示闲置或者僵死的进程信息 |
| -p | 显示指定的进程信息 |

使用top命令通常不接收任何参数，若需要其他更强大的功能则需要配合交互命令，执行top命令：![image.png](https://cdn.nlark.com/yuque/0/2020/png/703037/1602400596784-e6c25967-02fa-4dc5-8682-02398ebc30b3.png#height=139&id=vn5do&margin=%5Bobject%20Object%5D&name=image.png&originHeight=139&originWidth=604&originalType=binary&ratio=1&size=70081&status=done&style=none&width=604)

**🧐说明：**  

| **option** | **说明** |
| --- | --- |
| **_第一行：任务队列信息，同uptime命令的执行结果_** |  |
| 15:13:15 | 当前系统时间 |
| up 101 days， 3:53 | 系统已经运行了101天3小时53分 |
| 1 user | 当前有1个用户登录系统 |
| load average: 0.15, 0.09, 0.09 | load average后面的三个数分别是1分钟、5分钟、15分钟的平均负载情况 |
| 第二行：Tasks为任务（进程） | 从上面的信息可以看出，系统现在共有130个进程，其中处于运行状态的有1个，129个在休眠（sleep），stoped状态0个，zombie状态（僵死）的有0个 |
| **_第三行：CPU状态信息_** |  |
| us | 用户空间占用CPU |
| sy | 内核空间占用CPU |
| ni | 改变过优先级的进程占用CPU |
| id | 空闲CPU |
| wa | I/O等待占用CPU |
| hi | 硬中断（Hardware IRQ）占用CPU |
| si | 软中断（Software Interrupts）占用CPU |
| st |  虚拟机占用CPU |
| **_第四行：内存状态_** |  |
| total | 物理内存总量 |
| used | 使用中的内存总量 |
| free | 空闲内存总量 |
| buffer/cache | 缓冲的内存量 |
| 第五行：swap交换分区信息 |  |
| **_第七行：各进程的状态监控_** |  |
| PID | 进程id |
| USER | 进程所有者 |
| PR | 进程优先级 |
| NI | 负值表示高优先级，正值表示低优先级 |
| VIRT | 进程使用的虚拟内存总量，单位为kb |
| RES | 进程使用的、未被换出的物理内存大小，单位为kb |
| SHR  | 共享内存大小，单位为kb |
| S | 进程状态。D=不可中断的睡眠状态R=运行S=睡眠T=跟踪/停止Z=僵尸进程。 |
| %CPU | 上次更新到现在的CPU时间占用百分比 |
| %MEM | 进程使用的物理内存百分比 |
| TIME+ | 进程使用的CPU时间总计，单位1/100秒 |
| COMMAND | 进程名称（命令名/命令行） |

### `lsof`：查看进程打开的文件

lsof全名为list open files，也就是列举系统中已经被打开的文件，通过lsof命令，就可以根据文件找到对应的进程信息，也可以根据进程信息找到进程打开的文件

**👀语法格式：**  

```
lsof [option]
```

**🧐说明：**  

| **option** | **说明** |
| --- | --- |
| -c <进程名> | 显示指定的进程名所打开的文件 |
| -p <进程号> | 显示指定的进程号所打开的文件 |
| -i | 通过监听指定的协议、端口和主机等信息，显示符合条件的进程信息 * |
| -u | 显示指定用户使用的文件 |

如果想知道某个特定的文件是由哪个进程在使用，就可以通过“lsof 文件名”的方式来得到**监听指定的协议、端口和主机等信息，显示符合条件的进程信息**。

**👀语法格式：**  

```
lsof -i [46] [protocol] [@hostname] [:service|port]
```

**🧐说明：**  

- 46：4代表IPv4，6代表IPv6
- protocol：传输协议，可以是TCP或UDP
- hostname：主机名称或者IP地址
- service：进程的服务名，例如NFS、SSH和FTP等
- port：系统中与服务对应的端口号。例如HTTP服务默认对应的端口号为80，SSH服务默认对应的端口号为22

## 7. 网络管理

### `ifconfig`：配置或显示网络接口信息

ifconfig命令用于配置网卡IP地址等网络参数或显示当前网络的接口状态，其类似于Windows下的ipconfig命令

**👀语法格式：**  

```
ifconfig [interface] [option]
```

**🧐说明：**  

- interface为网络接口名，Linux下的网络接口名类似于eth0、eth1和lo等，分别表示第1块网卡、第2块网卡和回环接口。这是个可选项，如果不添加此选项，则显示系统中所有的网卡信息；如果添加此选项，则显示指定的网卡信息。
- 使用ifconfig命令配置网卡信息仅会临时生效，重启网络或服务器配置就会失效

### `ping`：测试主机之间网络的连通性

ping命令可用于测试主机之间网络的连通性。执行ping命令会使用ICMP传输协议，发出要求回应的信息，若远端主机的网络功能没有问题，就会回应该信息，因而可得知该主机运作正常

**👀语法格式：**  

```
ping [option] [目标主机]

// 🌰例如：
ping www.baidu.com
```

### `telnet`：远程登录主机

telnet命令以前是用于登录远程主机，对远程主机进行管理的。但是因为telnet是采用明文传送报文的，其安全性不好，因此现在很多Linux服务器都不开放telnet服务，而是改用更安全的SSH服务了。当然，交换机等网络设备还是会采用telnet登录的方式
现在使用telnet命令的场景主要是判断远端服务器的端口是否开放

**👀语法格式：**  

```
telnet [option] [host] [port]
```

### `ssh`：安全地远程登录主机

ssh命令是openssh套件中的客户端连接工具，可以使用ssh加密协议实现安全的远程登录服务器，实现对服务器的远程管理，Windows中的替代工具为Xshell、putty、SecureCRT等

**👀语法格式：**  

```
ssh [option] [user@]hostname [command] // ssh [用户@]主机名或IP地址 [远程执行的命令]
```

**🧐说明：**  

如果省略了用户，则默认是当前执行ssh命令的用户

| **option** | **说明** |
| --- | --- |
| -p | 指定ssh登录端口，如果忽略则默认端口为22 |
| -v | 调试模式 |

### `wget`：命令行下载工具

wget命令用于从网络上下载某些资料，该命令对于能够连接到互联网的Linux系统的作用非常大，可以直接从网络上下载自己所需要的文件

**👀语法格式：**  

```
wget [option] [url]
```

**🧐说明：**  

| **option** | **说明** |
| --- | --- |
| -o | 将命令的执行结果写入文件中 |
| -O | 指定保存的文件名后下载文件 * |
| --limit-rate | 限速下载 |
| -c | 断点续传 * |

### `curl`：命令行文件传输工具

curl是一个综合传输工具，既可以用来上传文件，也可以用来下载文件，在日常使用过程中，它通常都是以下载工具的角色出现，常用来检验一个网址是否可以访问。

**👀语法格式：**  

```
curl [option] [url]

// 🌰例如： 
curl www.baidu.com
```

### `nslookup`：域名查询工具

nslookup命令是常用的域名解析查询工具

**👀语法格式：**  

```
nslookup [option] [name] [server] // nslookup [option] [域名/ip] [DNS服务器]

// 🌰例如：
nslookup www.baidu.com
```

### `host`：域名查询工具

host命令是用于查询DNS的工具，它可以将指定主机名称转换为IP地址

**👀语法格式：**  

```
host [option]
```

**🧐说明：**  

| **option** | **说明** |
| --- | --- |
| -a | 显示详细的DNS信息 |

## 8. 软件包管理

### 高级软件包管理工具

目前主要的高级软件包管理工具有Yum和APT两种：

- Yum（Yellow dog Updater，Modified）是一个基于RPM包的软件包管理器，能够从指定的服务器自动下载RPM包并且完成安装，可以处理依赖性关系，并且一次安装所有依赖的软件包，无需用户繁琐地一次次下载、安装。Red Hat Enterprise Linux、CentOS、Fedora等Linux发行版采用Yum
- APT（Advanced Packaging Tools）可译为高级软件包工具，是Debian及其派生发行版（如Ubuntu）的软件包管理器。APT可以自动下载、配置、安装二进制或者源代码格式的软件包，甚至只需一条命令就能更新整个系统的所有软件。Ubuntu主要使用Deb软件包，建议首选APT工具

### APT工具安装

常用的APT命令行工具有两个，apt-get用于执行与软件包安装有关的所有操作，apt-cache用于查询软件包的相关信息。

#### apt-cache：查询软件包的相关信息

apt-cache命令用于在APT的软件包缓存中搜索软件，收集软件包信息，获知哪些是可以在Ubuntu或Debian上安装的软件。由于支持模糊查询，apt-cache查询非常方便。

**👀语法格式：**  

```
apt-cache [子命令] pkgnames
```

**🧐说明：**  

| **子命令** | **说明** |
| --- | --- |
| search | 查找指定软件包并列出该软件包的相关信息 |
| show | 查看指定名称的软件包的详细信息 |
| depends | 查看软件包依赖的软件包 |
| showpkg | 查看软件包的依赖关系信息 |
| policy | 显示软件包的安装状态和版本信息 |

#### apt-get：操作软件包

命令apt-get会自动帮助用户下载并安装所需的程序包或代码。apt-get命令一般需要root权限执行，所以还要使用sudo命令

**👀语法格式：**  

```
sudo apt-get 子命令 pkgnames
```

**🧐说明：**  

| **子命令** | **说明** |
| --- | --- |
| update | 获取最新的软件包列表 |
| upgrade | 更新当前系统中所有已安装的软件包，并同时更新这些软件包的依赖 |
| install | 下载、安装软件包并自动解决依赖关系 |
| remove | 卸载指定的软件包 |
| purge | 卸载指定的软件包及其配置文件 |
| source | 下载软件包的源代码 |
| clean | 清理已下载的软件包，不会影响软件的正常使用 |
| autoclean | 删除已卸载的软件的软件包备份 |

#### apt：管理软件包

apt 命令的引入就是为了解决命令过于分散的问题，它包括了 apt-get 命令出现以来使用最广泛的功能选项，以及 apt-cache 和 apt-config 命令中很少用到的功能。
在使用 apt 命令时，用户不必再由 apt-get 转到 apt-cache 或 apt-config，而且 apt 更加结构化，并为用户提供了管理软件包所需的必要选项。
简单来说就是：apt = apt-get、apt-cache 和 apt-config 中最常用命令选项的集合

### [nginx安装示例](http://nginx.org/en/linux_packages.html#instructions)

### 源码安装

如果APT、Deb软件包不能提供所需的软件，就要考虑源代码安装，获取源代码包，进行编译安装。另外源代码包可以根据用户的需要对软件加以定制，有的还允许二次开发。
**1.下载和解压软件包**
下载源代码包文件后，首先需要解压缩。Linux中一般将源代码包复制到/usr/local/src目录下再解压缩。完成解压缩后，进入解压后的目录下，查阅INSTALL与README等相关帮助文档，了解该软件的安装要求、软件的工作项目、安装参数配置及技巧等，这一步很重要。安装帮助文档也会说明要安装的依赖性软件。依赖性软件的安装很必要，是成功安装源代码包的前提。
**2.执行configure生成编译配置文件Makefile**
源代码需要编译成二进制代码再进行安装。自动编译需要Makefile文件，在源代码包中使用configure命令生成。多数源代码包都提供一个名为configure的文件，它实际上是一个使用Bash脚本编写的程序。
configure通常会提供若干选项供用户选择。每个源代码包中configure命令选项不完全相同，实际应用中可以执行命令./configure–help来查看。其中比较重要的就是--prefix选项，它后面给出的路径就是软件要安装到的那个目录，如果不用该选项，默认将安装到/usr/local目录。

| **选项** | **说明** |
| --- | --- |
| --help | 提供帮助信息 |
| --prefix=path | 指定软件安装位置，默认/usr/local * |
| --exec-prefix=path | 指定可执行文件安装路径 |

**3.执行make命令编译源代码**
make会依据Makefile文件中的设置对源代码进行编译并生成可执行的二进制文件。编译工作主要是运行gcc将源代码编译成为可以执行的目标文件，但是这些目标文件通常还需要连接一些函数库才能产生一个完整的可执行文件。使用make就是要将源代码编译成为可执行文件，放置在目前所在的目录之下，此时还没有安装到指定目录中。
**4. 执行make install安装软件**
make只是生成可执行文件，要将可执行文件安装到系统中，还需执行makeinstall命令。通常这是最后的安装步骤了，make根据Makefile文件中关于install目标的设置，将上一步骤所编译完成的二进制文件、库和配置文件等安装到预定的目录中。
另外，执行make install安装的软件通常可以执行make clean命令卸载。
