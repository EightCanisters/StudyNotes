> 本文旨在从浏览器的进程线程的角度，解答浏览器端从用户输入网站链接到页面展示出来经历了什么。

## 前言：复习Chrome的进程&线程

前边学习了[什么是进程线程](https://www.yuque.com/docs/share/13d7cb2c-edd0-40cc-bbd7-e96c43a5e35f)，以及[Chrome的进程&线程](https://www.yuque.com/docs/share/b6cdec74-a2b0-4415-96f9-1084643475da)，对Chrome进程架构不熟悉的伙伴可以先看看哦，也可以直接看下图：
![Chrome的进程&线程](https://gitee.com/ahuang6027/blog-images/raw/master/images/processes-and-threads-of-chrome.png)

接下来，咱就从URL输入地址栏开始，一起看看浏览器是怎么工作的😊

## 导航阶段（`Browser进程`）

这一阶段主要是`Browser进程`的工作。

### 处理输入

`UI线程`对输入内容进行分析：

1. 对于Chrome浏览器来说，导航栏中的输入既可能是一个可以直接请求的域名，又可能是用户想使用搜索引擎搜索的关键词信息;
2. 所以当用户在地址栏输入内容时，`UI线程`会对其进行一系列的解析来判定是将用户输入发送给搜索引擎，还是直接请求输入的URL的资源。

### 开始导航

确定地址栏中输入的内容为网站URL后：

1. `UI线程`叫`网络线程`初始化一个网络请求，用来获取站点的内容；
2. `UI线程`会在tab页旁边显示一个提示加载的旋转圆圈；
3. `网络线程`会先进行`DNS寻址`、为请求`建立TLS连接`等一系列操作，然后将网络请求发出；

### 读取响应

网络请求发出后，服务器会对请求进行响应：

1. `网络线程`确定响应的媒体类型(MIME Type)：
   1. 接收HTTP响应时，必要时会通过HTTP头部的`Content-Type`来确定媒体类型；
   2. `注意：`有时会发生`Content-Type`确实或错误的情况，此时`网络线程`就会进行[`MIME类型嗅探`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types)来确定响应类型了。
2. 如果响应主体是其他类型的文件(非HTML，如压缩文件)，`网络线程`会将响应数据交给`下载管理器`(download manager)来处理。
3. 如果响应主体是HTML文件：
   1. `网络线程`会先对响应内容做检查：
      1. 做[SafeBrowsing](https://safebrowsing.google.com/)检查：确认响应内容是否为恶意站点。如果是，`网络线程`会给用户展示一个警告页；
      2. 还会做[CORB(Cross Origin Read Blocking)](https://www.chromium.org/Home/chromium-security/corb-for-developers)检查：确定是否包含敏感的跨站数据，即检查是否跨域。
   2. 然后`网络线程`会将获取的响应数据交给`Renderer进程`。

### 寻找渲染进程

1. `网络线程`做完请求后，它会告诉`UI线程`数据准备好了；
2. `UI线程`会为这个网站寻找一个`Renderer进程`来渲染界面。

> 【❗❗注意】由于网络请求耗费时间太长，为了缩短导航到渲染的整个时间，浏览器是做了优化的：
>
> - 在第二步（开始导航）中，`UI线程`发送URL链接给`网络线程`后，`网络线程`就已经知道了目的站点；
> - 在`网络线程`干活的同时，`UI线程`会主动地为这个网络请求启动一个`Renderer进程`；
> - `网络线程`做完请求后，如果一切顺利（没有重定向，安全检查也通过了），`UI线程`就直接找到建好的这个`Renderer进程`
> - 如果网站被重定向到了另一个站点，那么会摒弃刚刚建好的这个`Renderer进程`，`UI线程`再为新站点寻找一个`新的Renderer进程`。

### 提交(Commit)导航

> IPC：可以简单理解为进程之间通信的通道。

1. commit导航：`UI线程`准备好`Renderer进程`后，`Browser进程`会通过**IPC**告诉`Renderer进程`去提交本次导航;
2. commit成功，导航阶段结束，文档加载阶段开始：`Browser进程`接收到`Renderer进程`的回复（commit成功）后，导航过程就结束了，页面文档的解析阶段会正式开始。  
此时，`UI线程`还会做如下操作：
   1. 更新导航栏、安全指示符（security indicator）和站点设置UI（site settings UI）会展示新页面相关的站点信息；
   2. 更新当前tab的会话历史（session history）：这样当用户点击浏览器的前进/后退按钮时也可以导航到刚刚导航完的页面；
   3. 将当前的会话历史保存到磁盘：为了方便关闭tab或窗口的时候还可以恢复当前tab的会话内容，会将当前的会话历史保存到磁盘中。

接下来就正式进入页面的解析渲染阶段啦！

## 解析阶段（`Renderer进程`）

浏览器解析渲染过程大致是这样的：

![浏览器解析渲染过程](https://gitee.com/ahuang6027/blog-images/raw/master/images/process-browser-parse-flow.png)

本文主要从进程、线程的角度来看解析和渲染。

### 构建DOM

1. `Renderer进程`接收`Browser进程`提供的HTML数据；
2. 同时`主线程(GUI渲染线程)`也会开始解析HTML文本，并将它转化为`DOM`。

### 子资源(图片、CSS、JS等)加载

一个网站，除了HTML文件外，通常还包括如图片、CSS样式、JS脚本等子资源，这些文件会从缓存或者网络上获取：

1. `主线程(GUI渲染线程)`会按照构建DOM时遇到的各个资源的顺序，一个一个地发起网络请求。
   1. 注意：为了提升效率，浏览器会同时运行“预加载扫描（preload scanner）”程序

## 页面渲染完成

1. 告知`Browser进程`：`Renderer进程`“完成”（finished）渲染后，会通过IPC告知`Browser进程`。
   1. 注意：告知操作发生在页面上所有的帧（frames）的**onload**事件都已经被触发，且对应的处理函数都已经处理完成时。
2. `UI线程`将tab页旁提示加载的旋转圆圈**停止旋转**。
3. 注意：这里只是完成渲染，后边客户端的JS还是可以继续加载资源，也可以改变视图内容。

## 补充：在当前tab页中重新导航

前边只介绍了在全新tab页中网页的加载渲染过程，没有涉及其他情况。比如网页渲染完成后直接在导航栏中修改url地址、JS代码中修改了window.location造成重新导航……

其实与之前的步骤没有什么不同，只是多了收尾工作：

1. 当前的`Renderer进程`处理收尾工作：
   1. `Browser进程`会询问一下当前的`Renderer进程`需不需要处理一下`beforeunload`事件，需要就会给用户展示一个“你确定要离开当前页面吗？”的二次确认弹框；
   2. 除了`beforeunload`，也还有`unload`等其他的，具体看[页面的生命周期文章](https://developer.chrome.com/blog/page-lifecycle-api/#overview_of_page_lifecycle_states_and_events)。
2. 如果是导航到不同的站点，`UI线程`会启动一个`全新的Renderer进程`，`当前的Renderer进程`则继续收尾。

## 补充：假如使用了Service Worker

### Service Worker是什么

Service worker可以用来写网站的网络代理（network proxy），所以开发者可以对网络请求有更多的控制权，例如决定哪些数据缓存在本地以及哪些数据需要从网络上面重新获取等等。如果开发者在service worker里设置了当前的页面内容从缓存里面获取，当前页面的渲染就不需要重新发送网络请求了，这就大大加快了整个导航的过程。

### Service Worker如被被执行

这里要重点留意的是**service worker其实只是一些跑在Renderer进程里面的JavaScript代码**。那么问题来了，当导航开始的时候，`Browser进程`是如何判断要导航的站点存不存在对应的service worker并启动一个`Renderer进程`去执行它的呢？

其实service worker在注册的时候，它的**作用范围（scope）**会被记录下来。在导航开始的时候，`网络线程`会根据请求的域名在已经注册的service worker作用范围里面寻找有没有对应的service worker。如果有命中该URL的service worker，`UI线程`就会为这个service worker启动一个`Renderer进程`来执行它的代码。Service worker既可能使用之前缓存的数据也可能发起新的网络请求。

### 导航预加载（Navigation Preload）

如果启动的service worker最后还是决定发送网络请求的话，浏览器进程和渲染进程这一来一回的通信包括service worker启动的时间其实**增加了页面导航的时延**。

导航预加载就是一种通过在service worker启动的时候并行加载对应资源的方式来加快整个导航过程效率的技术。预加载资源的请求头会有一些特殊的标志来让服务器决定是发送全新的内容给客户端还是只发送更新了的数据给客户端。

![UI线程在启动一个Renderer进程去运行service worker代码的同时会并行发送网络请求](https://gitee.com/ahuang6027/blog-images/raw/master/images/process-url-or-seartext.png)

## 参考

- [浏览器的进程、线程与页面渲染流程](http://marswiz.com/blog/2021/09/20/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E8%BF%9B%E7%A8%8B-%E7%BA%BF%E7%A8%8B%E4%B8%8E%E9%A1%B5%E9%9D%A2%E6%B8%B2%E6%9F%93%E6%B5%81%E7%A8%8B/)
- [Inside look at modern web browser(part1 - part4)](https://developers.google.com/web/updates/2018/09/inside-browser-part2)
- [一文看懂Chrome浏览器运行机制](https://zhuanlan.zhihu.com/p/102149546)
- [从Chromium源码来窥探浏览器的渲染](https://mp.weixin.qq.com/s/r1nAcEkEoE1D7CgQwqSe2Q)
