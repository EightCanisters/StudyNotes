> 本文是笔者根据[深入理解JavaScript作用域和作用域链](https://juejin.cn/post/6844904165672484871)和[面试官：说说作用域和闭包吧](https://juejin.cn/post/6844903797135769614)两篇文章，再加上《你不知道的JavaScript》总结后的产物。

## 1. `LHS`和`RHS`查询

虽然javascript被认为是一门解释型语言/动态语言，但是它其实是一种**编译型**的语言。  
一般来说，运行一段javascript代码，有两个必不可少的东西：JS**引擎**和**编译器**：

- 引擎类似于总管的角色，负责整个程序运行时所需的各种资源的调度；
- 编译器只是引擎的一部分，负责将 javascript 源码编译成机器能识别的机器指令，然后交给引擎运行。

### 1.1. 编译

在 javascript 中，一段源码在被执行之前大概会经历以下三个步骤，这也被称之为**编译**：

1. **分词 / 词法分析**：编译器会先将一连串字符打断成（对于语言来说）有意义的片段，称为**token（记号）**，例如`var a = 2;`。这段程序很可能会被打断成如下token：`var`，`a`，`=`，`2`，和`;`；
2. **解析 / 语法分析**：编译器将一个token的流（数组）转换为一个“**抽象语法树**”（AST —— Abstract Syntax Tree），它表示了程序的语法结构。
3. **代码生成**：编译器将上一步中生成的抽象语法树转换为机器指令，等待引擎执行。

### 1.2. 执行（`LHS`和`RHS`登场）

编译器一顿操作猛如虎，生成了一堆机器指令，JS 引擎开心地拿到这堆指令，开始执行，这个时候我们要说的`LHS`和`RHS`就登场了。

#### 1.2.1. `LHS`和`RHS`

`LHS (Left-hand Side)`和`RHS (Right-hand Side)`，是在代码执行阶段JS引擎操作变量的两种方式，二者区别就是对变量的查询目的是**变量赋值**还是**查询**。

- `LHS`：找到变量容器的本身（或者说：找到赋值操作的目标）。可以理解为变量在赋值操作符(=)的**左侧**，例如`a = 1`，当前引擎对变量`a`查找的目的是变量赋值。这种情况下，引擎不关心变量`a`原始值是什么，只管将值`1`赋给`a` 变量。
- `RHS`：找到变量的值（或者说：找到赋值操作的源头）。可以理解为变量在赋值操作符(=)的**右侧**，例如：`console.log(a)`，其中引擎对变量`a`的查找目的就是查询，它需要找到变量`a`对应的实际值是什么，然后才能将它打印出来。

#### 1.2.2. 栗子🌰

```js
var a = 2; // 引擎对a做了LHS查询，找到a，并把新值2赋给它

function foo(a) { // 对a做了LHS查询
  console.log( a ); // 对a做了RHS查询，对console.log做了LHS查询
}

foo( 2 ); // 对foo做了RHS 查询
```

总之，引擎想对变量进行获取 / 赋值，就离不开`LHS`和`RHS`，然而这两个操作只是手段，到哪里去获取变量才是关键。`LHS`和`RHS`获取变量的位置就是**作用域**。

## 2. 作用域

### 2.1. 什么是作用域

作用域是在运行时代码中的某些特定部分中变量，函数和对象的可访问性。换句话说，作用域决定了代码区块中变量和其他资源的可见性。

可能这两句话并不好理解，我们先来看个栗子🌰：

```js
function outFun2() {
    var inVariable = "内层变量2";
}
outFun2();//要先执行这个函数，否则根本不知道里面是啥
console.log(inVariable); // Uncaught ReferenceError: inVariable is not defined
```

从上面的例子可以体会到作用域的概念，变量inVariable在全局作用域没有声明，所以在全局作用域下取值会报错。我们可以这样理解：**作用域就是一个独立的地盘，让变量不会外泄、暴露出去**。也就是说**作用域最大的用处就是隔离变量，不同作用域下同名变量不会有冲突**。

### 2.2. 作用域类型

**ES6之前**JavaScript没有块级作用域,**只有全局作用域和函数作用域**。ES6的到来，为我们提供了块级作用域,可通过新增命令let和const来体现。

#### 2.2.1. 全局作用域

全局作用域为程序的最外层作用域，一直存在。在代码中任何地方都能访问到的对象拥有全局作用域。

一般来说以下几种情形拥有全局作用域：

- 最外层函数和在最外层函数外面定义的变量拥有全局作用域

  ```js
  var outVariable = "我是最外层变量"; //最外层变量
  function outFun() { //最外层函数
      var inVariable = "内层变量";
      function innerFun() { //内层函数
          console.log(inVariable);
      }
      innerFun();
  }
  console.log(outVariable); //我是最外层变量
  outFun(); //内层变量
  console.log(inVariable); //inVariable is not defined
  innerFun(); //innerFun is not defined
  ```

- 所有末定义直接赋值的变量自动声明为拥有全局作用域

  ```js
  function outFun2() {
    variable = "未定义直接赋值的变量";
    var inVariable2 = "内层变量2";
  }
  outFun2();//要先执行这个函数，否则根本不知道里面是啥
  console.log(variable); //未定义直接赋值的变量
  console.log(inVariable2); //inVariable2 is not defined
  ```

- 所有window对象的属性拥有全局作用域。
  - 一般情况下，window对象的内置属性都拥有全局作用域，例如window.name、window.location、window.top等等。
  - 全局作用域有个弊端：如果我们写了很多行 JS 代码，变量定义都没有用函数包括，那么它们就全部都在全局作用域中。这样就会 污染全局命名空间, 容易引起**命名冲突**。

    ```js
    // 张三写的代码中
    var data = {a: 100}

    // 李四写的代码中
    var data = {x: true}
    ```

#### 2.2.2. 函数作用域

函数作用域只有函数被定义时才会创建，包含在父级函数作用域 / 全局作用域内。

```js
function doSomething(){
    var blogName="博客名";
    function innerSay(){
        alert(blogName);
    }
    innerSay();
}
alert(blogName); // 报错
innerSay(); // 报错
```

#### 2.2.3. 块级作用域

**以下4种情况会创建块级作用域：**

![](https://gitee.com/ahuang6027/blog-images/raw/master/images/块级作用域-创建.png)

**块级作用域有以下几个特点：**

- 声明变量不会提升到代码块顶部；

  ```js
  function getValue(condition) {
    if (condition) {
      let value = "blue";
      return value;
    } else {
      // value 在此处不可用
      return null;
    }
    // value 在此处不可用
  }
  ```

- 禁止重复声明。如果一个标识符已经在代码块内部被定义，那么在此代码块内使用同一个标识符进行 let 声明就会导致抛出错误；

  ```js
  var count = 30;
  let count = 40; // Uncaught SyntaxError: Identifier 'count' has already been declared
  if (condition) {
    let count = 40; // 不报错，可以声明
    // 其他代码
  }
  ```

- 循环中的绑定块作用域的妙用。

  ```js
  // 🌰栗子1：i只在for循环体内有效，在循环体外引用就会报错
  for (let i = 0; i < 10; i++) { // 在for里let i，把声明的计数器变量限制在循环内
    // ...
  }
  console.log(i); // ReferenceError: i is not defined

  // 🌰栗子2：使用var声明计数器变量的for循环
  // 本例中，变量i是var命令声明的，在全局范围内都有效，所以全局只有一个变量i。
  // 每一次循环，变量i的值都会发生改变，而循环内被赋给数组a的函数内部的console.log(i)，里面的i指向的就是全局的i。也就是说，所有数组a的成员里面的i，指向的都是同一个i，导致运行时输出的是最后一轮的i的值，也就是 10。
  var a = [];
  for (var i = 0; i < 10; i++) {
    a[i] = function () {
      console.log(i);
    };
  }
  a[6](); // 10

  // 🌰栗子3：使用let声明计数器变量的for循环
  // 本例中，变量i是let声明的，当前的i只在本轮循环有效，所以每一次循环的i其实都是一个新的变量，所以最后输出的是6。
  // 你可能会问，如果每一轮循环的变量i都是重新声明的，那它怎么知道上一轮循环的值，从而计算出本轮循环的值？
  // 这是因为 JavaScript 引擎内部会记住上一轮循环的值，初始化本轮的变量i时，就在上一轮循环的基础上进行计算。
  var a = [];
  for (let i = 0; i < 10; i++) {
    a[i] = function () {
      console.log(i);
    };
  }
  a[6](); // 6

  // 🌰栗子4：for循环还有一个特别之处，就是设置循环变量的那部分是一个父作用域，而循环体内部是一个单独的子作用域。
  for (let i = 0; i < 3; i++) {
    let i = 'abc';
    console.log(i); 
  } // 会打印三个abc
  ```

## 3. 作用域链

### 3.1. 什么是作用域链

当可执行代码内部访问变量时，引擎会从当前的执行作用域开始查找，如果找到目标变量即返回，否则会去父级作用域继续查找...一直找到最外层的全局作用域，若依然没有找到，则会停止查找并报错。我们把这种作用域的嵌套机制，称为**作用域链**。

### 3.2. 栗子🌰

```js
function foo(a) {
  var b = a * 2;

  function bar(c) {
    console.log( a, b, c );
  }

  bar(b * 3);
}

foo(2); // 2 4 12
```

结合前面的知识我们知道，在`bar`函数内部，会做三次`RHS`查询从而分别获取到`a b c`三个变量的值。`bar`内部作用域中只能获取到变量`c`的值，`a`和`b`都是从外部`foo`函数的作用域中获取到的。

用泡泡来比喻本例的作用域可能好理解一点：  
![](https://gitee.com/ahuang6027/blog-images/raw/master/images/作用域链-泡泡图.png)

用图片表示，上述代码一共有三层作用域嵌套，分别是：全局作用域，`foo`作用域，`bar`作用域。

### 3.3. 未找到时抛出异常

从作用域链中查找变量，找到最外层全局作用域仍未找到时，就会抛出异常。一般有两种异常：

- `ReferenceError`：同作用域判别失败相关：
  - 情况1：RHS查询失败（在所有嵌套的作用域中都找不到）；
  - 情况2：严格模式下，LHS查询失败；（非严格模式下，LHS找不到会在全局作用域自动创建一个）。
- `TypeError`：作用域判别成功，但对结果的操作非法或不合理:
  - 情况1：RHS查找成功，但对这个变量的值进行了不合理的操作（比如对黑函数类型的值进行函数调用）。  

## 4. 词法作用域

### 4.1. 词法作用域是什么

词法作用域（Lexical Scopes）是javascript中使用的**作用域类型**，词法作用域也可以被叫做**静态作用域**，与之相对的还有动态作用域。

词法作用域，就意味着**变量被定义的时候，它的作用域就已经确定了**，和拿到哪里执行没有关系，因此词法作用域也被称为“**静态作用域**”。

可能看到这里还很懵，我们来看个栗子🌰：

```js
var value = 1;

function foo() {
  console.log(value);
}

function bar() {
  var value = 2;
  foo();
}

bar(); // 这里结果是1哦
```

### 4.2. 欺骗词法

作用域是在变量定义的时候确定的，但是，如果我们仍然想达到类似于动态作用域的效果，需要怎么做呢？

其实JS给我们提供了两个方法：`eval`和`with`

- `eval`：可以在写的代码中用程序动态生成代码并运行，就好像代码是写在那个位置地一样。

  ```js
  function foo(str, a) {
    eval( str );
    console.log( a, b );
  }

  var b = 2;

  foo( "var b = 3;", 1 ); // 1 3
  ```

- `with`：通常被当作重复引用同一个对象中的多个属性的快捷方式，可以不需要重复引用对象本身。

  ```js
  function foo(obj) {
    with (obj) {
      a = 2;
    }
  }

  var o1 = {
    a: 3
  };

  var o2 = {
    b: 3
  };

  foo( o1 );
  console.log( o1.a ); // 2

  foo( o2 );
  console.log( o2.a ); // undefined
  console.log( a ); // 2 -- 全局作用域被泄漏了！
  ```

## 5. 作用域与执行上下文

许多开发人员经常混淆作用域和执行上下文的概念，误认为它们是相同的概念，但事实并非如此。

我们知道JavaScript的作用域是词法作用域，作用域在函数定义时就已经确定了，而不是在函数调用时确定。但是**执行上下文是函数执行之前创建的**。执行上下文最明显的就是this的指向是执行时确定的。而作用域访问的变量是编写代码的结构确定的。

作用域和执行上下文之间最大的区别是： **执行上下文在运行时确定，随时可能改变；作用域在定义时就确定，并且不会改变**。

一个作用域下可能包含若干个上下文环境。有可能从来没有过上下文环境（函数从来就没有被调用过）；有可能有过，现在函数被调用完毕后，上下文环境被销毁了；有可能同时存在一个或多个（闭包）。**同一个作用域下，不同的调用会产生不同的执行上下文环境，继而产生不同的变量的值。**
