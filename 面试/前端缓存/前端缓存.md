# 1. 前言
前端缓存与浏览器存储不一样。   
缓存: cache   
浏览器存储：sessionStorage, localStorage, cookie, indexedDB...

## 1.1 什么时候会缓存
针对某一个资源，比如index.html。如果设置了缓存策略，第一次请求该资源后，浏览器会将其缓存。在后续的请求时，如果缓存未过时，则拿缓存里的资源且状态码为200。具体如何判断缓存是否过时，就要看使用的缓存类型了。


## 1.2 缓存位置：缓存区
浏览器有缓存区。优先存储在memory cache，其次是disk cache。

# 2. 缓存的种类
## 2.1 强制缓存
### 2.1.1 什么是强制缓存
- 第一次访问服务器取到数据之后，在过期时间之内不会再去重复请求，而是直接拿到浏览器缓存的资源。
- 注意：直接访问的资源不会走缓存，只有引用的资源走缓存。

#### 设置头：
```js
// 设置后：第一次请求后30秒内再发请求都走浏览器缓存
res.setHeader('Cache-Control', 'max-age=30'); // max-age单位为秒，相对时间
res.setHeader('Expires', new Date(Date.now() + 1000 * 30).toUTCString()); // expires针对低版本浏览器，且设置的
```

#### 例子：
```js
const fs = require('fs');
const http = require('http');
const url = require('url');
const path = require('path');

// 手写一个简单的静态服务器
const server = http.createServer((req, res) => {
    const { pathname } = url.parse(req.url);
    const filePath = path.join(__dirname, pathname);

    fs.stat(filePath, (err, stats) => {
        if(err) {
            res.statusCode = 404;
            res.end('Not found!');
        }
        if(stats?.isFile()) {
            console.log(filePath)
            // 设置后：第一次请求后30秒内再发请求都走浏览器缓存
            res.setHeader('Cache-Control', 'max-age=30'); // max-age单位为秒，相对时间
            res.setHeader('Expires', new Date(Date.now() + 1000 * 30).toUTCString()); // expires针对低版本浏览器，且设置的时绝对时间
            fs.createReadStream(filePath).pipe(res);
        } else {
            res.statusCode = 404;
            res.end('Not found!')
        }
    })
});

server.listen(3000, console.log('server listening on 3000'));
```

#### 运行结果：  
1）node端：
直接访问的资源不会走缓存，所以还是由node服务器返回。
![node服务-强制缓存](../../Others/images/强制缓存1.png)

2）浏览器：第二次请求   
![浏览器-强制缓存](../../Others/images/强制缓存-浏览器.png)

### 2.1.2 缺陷
- 超出设置的时间后，请求必然走服务器。若此时文件依然未修改，就会造成浪费。
- 没超出设置时间时，文件修改了，但依然走缓存，与实际不符。

### 2.1.3 使用场景
需要长时间缓存的东西，比如百度的logo

## 2.2 协商缓存
### 2.2.1 什么是协商缓存
向服务器发送请求，服务器会根据这个请求的request header的一些参数来判断是否命中协商缓存，如果命中，则返回304状态码并带上新的response header通知浏览器从缓存中读取资源；

### 2.2.2 协商缓存 - Last-Modified
根据资源的修改时间进行比较。
#### 设置头：
```js
res.setHeader('Last-Modified', mtime)
req.headers['if-modified-since'] == mtime
```

#### 例子：
```js
const fs = require('fs');
const http = require('http');
const url = require('url');
const path = require('path');

// 手写一个简单的静态服务器
const server = http.createServer((req, res) => {
    const { pathname } = url.parse(req.url);
    const filePath = path.join(__dirname, pathname);

    fs.stat(filePath, (err, stats) => {
        if(err) {
            res.statusCode = 404;
            res.end('Not found!');
        } else {
            if(stats && stats.isFile()) {
                console.log(filePath)
                const mtime = stats.ctime.toUTCString();
                if(req.headers['if-modified-since'] == mtime) {
                    res.statusCode = 304;
                    res.end();
                } else {
                    res.setHeader('Last-Modified', mtime)
                    fs.createReadStream(filePath).pipe(res);
                }
            } else {
                res.statusCode = 404;
                res.end('Not found!')
            }
        }
    })
});

server.listen(3000, console.log('server listening on 3000'));
```
#### 运行结果：
第二次请求时，先向服务器确认index.html是否过时。若服务器返回304，再走缓存。而index.css直接走了缓存。

1）node端：
直接访问的资源不会走缓存，所以还是由node服务器返回。
![node服务-协商缓存](../../Others/images/协商1-node.png)

2）浏览器：第二次请求

![浏览器-协商缓存](../../Others/images/协商1-浏览器.png)
![浏览器-协商缓存](../../Others/images/协商1-浏览器1.png)

#### 缺陷：
- 精度只达到秒级；
- 只会和上一次比较。若当前次和上上次修改一致，仍然不会走缓存。

### 2.2.3 协商缓存 - Etag
Etag：根据文件内容，摘要生成一个md5值。

#### 设置头：
```js
res.setHeader('Etag', etag)
req.headers['if-none-match']
```
#### 例子：
```js
const fs = require('fs');
const http = require('http');
const url = require('url');
const path = require('path');
const crypto = require('crypto');

// 手写一个简单的静态服务器
const server = http.createServer((req, res) => {
    const { pathname } = url.parse(req.url);
    const filePath = path.join(__dirname, pathname);

    fs.stat(filePath, (err, stats) => {
        if(err) {
            res.statusCode = 404;
            res.end('Not found!');
        } else {
            if(stats && stats.isFile()) {
                console.log(filePath)
                const etag = crypto.createHash('md5').update(fs.readFileSync(filePath)).digest('base64');
                if(req.headers['if-none-match'] == etag) {
                    res.statusCode = 304;
                    res.end();
                } else {
                    res.setHeader('Etag', etag)
                    fs.createReadStream(filePath).pipe(res);
                }
            } else {
                res.statusCode = 404;
                res.end('Not found!')
            }
        }
    })
});

server.listen(3000, console.log('server listening on 3000'));
```
#### 运行结果：  
第二次请求时，先向服务器确认index.html是否过时。若服务器返回304，再走缓存。

1）node端：
直接访问的资源不会走缓存，所以还是由node服务器返回。
![node服务-协商缓存](../../Others/images/协商2-node.png)

2）浏览器：第二次请求

![浏览器-协商缓存](../../Others/images/协商2-浏览器.png)
![浏览器-协商缓存](../../Others/images/协商2-浏览器1.png)

# 3. 最佳做法：强制与协商并存
![结合使用](../../Others/images/缓存.jpg)

# 4. 补充：加密
## 4.1 MD5摘要算法
- 不能解密，加密不可逆，因此不算加密算法。（网上很多都说md5加密算法，这种说法不对）
- 不安全，容易被反解。
## 4.2 加盐算法（如SHA1、SHA256）
- 一种摘要算法；
- 盐值一般存储在服务器，别人拿不到；
- 如：'123' + '盐值' ==> 摘要的结果。

# 5. 纯前端如何应对缓存（webpack）
在更新版本之后，如何让用户第一时间使用最新的资源文件呢？机智的前端们想出了一个方法，在更新版本的时候，顺便把静态资源的路径改了，这样，就相当于第一次访问这些资源，就不会存在缓存的问题了。
![webpack](../../Others/images/缓存-webpack.png)
```js
// 伟大的webpack可以让我们在打包的时候，在文件的命名上带上hash值。
entry:{
    main: path.join(__dirname,'./main.js'),
    vendor: ['react', 'antd']
},
output:{
    path:path.join(__dirname,'./dist'),
    publicPath: '/dist/',
    filname: 'bundle.[chunkhash].js'
}
```