## 1. 前言

### 1.1. 唠嗑

说到原型，就必然涉及构造函数、类等概念，我会把这部分放到后边的拓展中，如果不清楚的可以先看拓展部分~

本文是找了一些资料(文章)看了后做的总结，有些地方可能理解的不是很深刻，有错误一定要帮我指出来，非常感谢~  
最近在看《你不知道的Javascript》，后边看了原型的内容后会再更新==

### 1.2. 开讲前

- **对象**：拥有`__proto__`和`constructor`属性；
  - `__proto__`和`constructor`**对象**独有的。
- **函数**：拥有`prototype`、`__proto__`和`constructor`属性；
  - `prototype`是**函数**独有的；
  - 由于JS中函数也是对象，所以函数也有`__proto__`和`constructor`属性。
- JS中引用类型都是对象，都有`prototype`、`__proto__`和`constructor`属性；
- 注：`[[Prototype]]`和`__proto__`其实是一回事：都表示原型链中的“连接”。在 JavaScript语言标准中用的`[[prototype]]` (官方的)，而`__proto__`是很多浏览器提供的 (非官方)；

## 2. 图解prototype、__proto__、constructor、实例、构造函数

### 2.1. 先说结论

- `prototype`、`__proto__`、`constructor`、`实例`、`构造函数`之间的关系：
  - 前置条件：
    - 实例 = new 构造函数()；
  - 实例:
    - 实例拥有`__proto__`和`constructor`属性；
    - 实例通过`__proto__`访问到它“爸爸”的原型：`构造函数.prototype`；
    - `实例.constructor`指向`实例的构造函数爸爸本身`；
  - 构造函数：
    - 构造函数拥有`prototype`、`__proto__`和`constructor`属性；
    - `构造函数.prototype`有两个属性：`constructor`和`__proto__`;
    - `构造函数.prototype.constructor`指向构造函数的原型：`构造函数.prototype`；
    - `构造函数.prototype.__proto__`指向`Object.prototype`（因为`构造函数.prototype`是一个对象）；
    - `构造函数.__proto__`指向`构造函数的爸爸.prototype`。
    - `构造函数.constructor`指向`构造函数它爸本身`。

我们来看一个简单的栗子（后面2.2-3的图都针对这个栗子哦）：

```js
function Father() {};
const son = new Father();
```

你知道son和Father的prototype、__proto__、constructor是怎样吗？如果下面代码判断对了，那说明原型功底还是很扎实哒！
不会也别着急，可以先跳过下面的浮想看后边的内容，看完之后再回过头来瞅瞅~  

由上面栗子产生的浮想：

```js
// 对象的__proto__指向父级的prototype
son.__proto__ === Father.prototype; // true
// 对象的构造器指向父构造函数
son.constructor === Father; // true
// 构造函数.prototype.constructor指向构造函数本身，所以实例对象的构造器也指向：构造函数.prototype.constructor
son.constructor === Father.prototype.constructor; // true

// 构造函数.prototype.constructor指向它本身
Father.prototype.constructor === Father; // true
// 构造函数.prototype是一个对象，对象的父级是Object，所以Father.prototype.__proto__指向Object.prototype
Father.prototype.__proto__ === Object.prototype; // true
// 构造函数Father的父级是Function，所以Father.__proto__指向Function.prototype
Father.__proto__ === Function.prototype; // true
// 构造函数的构造器是它的父级函数，所以...
Father.constructor === Function; // true
// 1) 构造函数.prototype.constructor指向构造函数本身，所以Function.prototype.constructor === Function; 2) 构造函数的构造器就是它的父级，所以Function.constructor === Function; 3) 所以两者相等
Father.constructor === Function.prototype.constructor; // true

// Function自己也是它的父构造函数的实例。这里是因为：构造函数.prototype.constructor指向构造函数本身
Function.prototype.constructor === Function; // true
// Function.prototype是一个对象，对象的上级是Object，所以...
Function.prototype.__proto__ === Object.prototype; // true
// Function自己也是它的父构造函数的实例，但它的父构造函数还是Function，所以...
Function.__proto__ === Function.prototype; // true
// Function.__proto__指向Function.prototype，是一个对象，对象没有prototype属性，所以是undefined
Function.__proto__.prototype === undefined; // true
// Function.__proto__指向Function.prototype, 构造函数.prototype.constructor指向自身，所以...
Function.__proto__.constructor === Function; // true
// Function.__proto__指向Function.prototype, 是一个对象，这个对象是Object的实例，所以...
Function.__proto__.__proto__ === Object.prototype; // true
// Function.__proto__.__proto__指向Object.prototype，构造函数.prototype.constructor指向构造函数自身，所以...
Function.__proto__.__proto__.constructor === Object; //true
// Function.__proto__.__proto__指向Object.prototype，Object.prototype的上一层是原型链的终点，JS规定值为null
Function.__proto__.__proto__.__proto__ === null; //true

// Object也是一个构造函数，构造函数.prototype.constructor指向构造函数自身
Object.prototype.constructor === Object; // true
// Object.prototype的上一层是原型链的终点，即null
Object.prototype.__proto__ === null; // true
// Object还是它父构造函数的一个实例，所以Object.__proto__指向了Function.prototype
Object.__proto__ === Function.prototype; // true
// Object.__proto__指向它的父构造函数.prototype，是一个对象，所以父构造函数.prototype再上一层则指向了Object.prototype
Object.__proto__.__proto__ === Object.prototype; // true
// Object.__proto__指向它的父构造函数.prototype，构造函数.prototype.constructor指向自身，所以...
Object.__proto__.constructor === Function; // true
// 1）Object.__proto__指向父构造函数.prototype，是一个对象；2）对象.__proto__指向Object.prototype；3）Object.prototype.__proto__为终点null
Object.__proto__.__proto__.__proto__ === null; // true
```

### 2.2. prototype原型

#### 简介

- prototype就是一个对象，又叫做原型对象，可以通过`函数.prototype`访问；
- prototype是**函数**独有的；
- 原型可以用来共享方法；
- 原型中this的指向是实例。

#### 图解

这里有一个构造函数`Father`，我们可以通过`Father.protorype`访问到它的原型。

![](https://gitee.com/ahuang6027/blog-images/raw/master/images/原型1.png)

### 2.3. instance实例

#### 简介

- 实例是`new`出来的**对象**，所以实例拥有`__proto__`和`constructor`两个属性；
- 实例会“继承”爸爸 (一般是父类或者构造函数) 的原型 (`prototype`)，会与爸爸共享原型。
  
#### 图解
  
这里使用new操作符创建了一个实例对象。

![](https://gitee.com/ahuang6027/blog-images/raw/master/images/原型2.png)

### 2.4. __proto__隐式原型

#### 简介

- `__proto__`是**对象**独有的；
- 实例通过`__proto__`访问它爸爸的原型。

#### 图解

![](https://gitee.com/ahuang6027/blog-images/raw/master/images/原型3.png)

所以`Father.prototype === son.__proto__`；

### 2.5. constructor构造器

#### 简介

- `constructor`是**对象**独有的；
- 既然构造函数通过`prototype`来访问到原型，那么原型也应该能够通过某种途径访问到构造函数，这就是`constructor`。

#### 图解

![](https://gitee.com/ahuang6027/blog-images/raw/master/images/原型4.png)

## 3. 原型链

### 3.1. 简介

原型可以通过`__proto__`访问到原型的原型。调用一个实例的方法时，会从实例开始查找这个方法。如果实例本身没有，会通过`__proto__`往父级查找，直到找到为止。如果找到终点也没找到，返回null。

这个搜索的过程形成的链状关系就是原型链。

### 3.2. 最后一张图

![](https://gitee.com/ahuang6027/blog-images/raw/master/images/原型链.png)

还记得开篇提到的那一长串浮想吗？现在倒回去看看，还会有收获哒~

## 4. 拓展

### 4.1. 构造函数

- 从外观来看，构造函数跟普通函数其实没啥区别，但它可以用new关键字创建对象；
- 一般来说，公共属性定义到构造函数里面，公共方法我们放到原型对象身上（原型上的方法才会被实例共享）。

#### 4.1.1. 实例成员和静态成员

- 实例成员：
  - 在构造函数内部，通过this添加的成员；
  - 只能通过实例化的对象来访问。
- 静态成员：
  - 在构造函数本身上添加的成员；
  - 只能通过构造函数来访问。
  
```js
function Person(name, age) {
  // 实例成员
  this.name = name;
  this.age = age;
}

// 静态成员
Person.sex = '女';

const p1 = new Person('LaoHuang', 24);
console.log(p1.name); // 'LaoHuang'
console.log(p1.age); // 24
console.log(p1.sex); // undefined (实例无法访问构造函数的静态成员)

console.log(Person.name); // Person undefined (构造函数无法直接访问实例成员，必须实例化后才能访问)
console.log(Person.sex); // 女 (构造函数可以访问它的静态成员)
```

#### 4.1.2. new一个实例

这个过程就是**实例化**。

```js
function Person(name) {
  this.name = name;
}

const p1 = new Person('LaoHuang');
console.log(p1) // Person {name: "LaoHuang"}
```

p1就是一个**实例对象**。new一个新对象的过程，大概有以下五步：

- 创建一个空对象p1： `{}`;
- 为p1准备原型链连接： `p1.__protp__ = Person.prototype`；
- 绑定this，使构造函数的this指向新对象p1：`Person.call(this)`；
- 为新对象的属性赋值：`p1.name`;
- 返回this：`return this`。此时的新对象就拥有构造函数的方法和属性了。

#### 4.1.3. 共享实例的方法

在构造函数的原型上添加的方法才会被实例共享。

```js
function Person(name) {
  this.name = name;
}
Person.prototype.getName = function() {
  console.log('名字：' + this.name);
}

const p1 = new Person('LaoHuang');
const p2 = new Person('FeiFei');
p1.getName(); // 名字：LaoHuang
p2.getName(); // 名字：FeiFei
console.log(p1.getName === p2.getName); // true
```

### 4.2. Class类

- 类的本质还是一个函数，它就是构造函数的另一种写法；
- 类没有变量提升，必须先定义，才能实例化；
- constructor方法是类的默认方法，通过new命令生成对象实例时，自动调用该方法。一个类必须有constructor方法，如果没有显式定义，会默认添加一个空的constructor方法;
- 类的所有方法都定义在它的`prototype`上:
  
  ```js
  Class Person {
    constructor(name) {
      this.name = name;
    }
    getName() {
      console.log('名字：' + this.name)；
    }
  }

  const p1 = new Person('LaoHuang');
  const p2 = new Person('FeiFei');
  p1.getName(); // 名字：LaoHuang
  p2.getName(); // 名字：FeiFei
  console.log(p1.getName === p2.getName); // true
  ```

#### 4.2.1. 如何向类中添加方法

使用`Object.assign()`。

```js
class Person {
  constructor(name, sex) {
    this.name = name;
    this.sex = sex;
  }
  getName() {
    console.log('名字：' + this.name);
  }
}

Object.assign(Person.prototype, {
  getSex(){
    console.log(this.name + '的性别是：' + this.sex)
  }
});

const p1 = new Person('LaoHuang', '女');
const p2 = new Person('FeiFei', '男');
p1.getSex(); // LaoHuang的性别是：女
p2.getSex(); // FeiFei的性别是：男
console.log(p1.getSex === p2.getSex); // true
```

### 4.3. 类和构造函数的区别

- 类必须使用new调用，否则会报错。这是它跟普通构造函数的一个主要区别，后者不用new也可以执行；
- 类的所有实例共享一个原型对象；
- 类的内部，默认就是严格模式，所以不需要使用`use strict`指定运行模式。

### 4.4. 继承

这里不展开讲继承，只涉及原型相关的。

#### 4.4.1. 构造函数+原型对象

```js
function Person(name) {
  this.name = name;
}
Person.prototype.getName = function () {
  console.log('名字：' + this.name);
};
function Girl(name, sex) {
  // 将实例化时，Person中的this指向当前实例
  Person.call(this, name);
  this.sex = sex;
}
// Girl.prototype = Person.prototype; // 用这种方式的话，给子类增加原型方法，同样会影响到父类
Girl.prototype = new Person();
Girl.prototype.sing = function () {
    console.log('I am singing');
};
let g1 = new Girl('小红', '女');
console.log(Person.prototype); // {getName: ƒ, constructor: ƒ}
console.log(Girl.prototype); // Person {name: undefined, sing: ƒ}
```

#### 4.4.2. extends语法糖

```js
 class Person {
  constructor(name){
    this.name = name;
  }
  getName(){
    return this.name;
  }
}
class Girl extends Person{
  constructor(name, sex){
    super(name);
    this.sex = sex;
  }
  getSex(){
    return this.getName() + '的性别：' + this.sex;
  }
}
const g1 = new Girl('小红', '女');
console.log(g1.getSex()); // 小红的性别：女
```

## 5. 参考

- [2020面试收获 - js原型及原型链](https://juejin.cn/post/6844904093828251662)
- [图解原型和原型链](https://juejin.cn/post/6844903797039300615)
- [MDN - 对象原型](https://developer.mozilla.org/zh-CN/docs/Learn/JavaScript/Objects/Object_prototypes)
